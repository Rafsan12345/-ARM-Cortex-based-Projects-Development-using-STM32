#include "stm32f103x6.h"  // CMSIS header for registers
#include <stdio.h>        // sprintf for UART printf-like

// ========================
// 1️⃣ GPIO INIT (LED & BUTTON)
// ========================
void GPIO_Init(void)
{
    // Enable GPIOC and GPIOA clocks
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN | RCC_APB2ENR_IOPAEN;

    // PC13 -> LED output (Push-Pull, 2MHz)
    GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);
    GPIOC->CRH |= (GPIO_CRH_MODE13_1);

    // PA0 -> Button input with pull-up
    GPIOA->CRL &= ~(GPIO_CRL_MODE0 | GPIO_CRL_CNF0);
    GPIOA->CRL |= GPIO_CRL_CNF0_1; // Input with pull-up/down
    GPIOA->ODR |= GPIO_ODR_ODR0;   // Pull-up
}

// ========================
// 2️⃣ SysTick (1ms Tick & Delay)
// ========================
volatile uint32_t msTicks = 0;
void SysTick_Handler(void)
{
    msTicks++;
}

void Delay_ms(uint32_t ms)
{
    uint32_t start = msTicks;
    while((msTicks - start) < ms);
}

// ========================
// 3️⃣ EXTI0 INIT (BUTTON INTERRUPT)
// ========================
void EXTI0_Init(void)
{
    // Enable AFIO clock
    RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;

    // Connect EXTI0 to PA0
    AFIO->EXTICR[0] &= ~AFIO_EXTICR1_EXTI0;
    AFIO->EXTICR[0] |= AFIO_EXTICR1_EXTI0_PA;

    // Enable EXTI0 interrupt
    EXTI->IMR |= EXTI_IMR_MR0;
    EXTI->FTSR |= EXTI_FTSR_TR0; // Falling edge

    // Enable EXTI0 in NVIC
    NVIC_EnableIRQ(EXTI0_IRQn);
}

void EXTI0_IRQHandler(void)
{
    if(EXTI->PR & EXTI_PR_PR0)
    {
        EXTI->PR |= EXTI_PR_PR0; // Clear pending
        GPIOC->ODR ^= GPIO_ODR_ODR13; // Toggle LED
    }
}

// ========================
// 4️⃣ UART1 INIT (TX / RX)
// ========================
void UART1_Init(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN | RCC_APB2ENR_IOPAEN;

    // PA9 -> TX (AF push-pull), PA10 -> RX (Input floating)
    GPIOA->CRH &= ~(GPIO_CRH_MODE9 | GPIO_CRH_CNF9);
    GPIOA->CRH |= GPIO_CRH_MODE9_1 | GPIO_CRH_CNF9_1; // TX AF PP
    GPIOA->CRH &= ~(GPIO_CRH_MODE10 | GPIO_CRH_CNF10);
    GPIOA->CRH |= GPIO_CRH_CNF10_0; // RX input floating

    USART1->BRR = 72000000/9600; // Assuming APB2 = 72MHz
    USART1->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;
}

void UART1_SendChar(char c)
{
    while(!(USART1->SR & USART_SR_TXE));
    USART1->DR = c;
}

void UART1_SendString(char *str)
{
    while(*str)
    {
        UART1_SendChar(*str++);
    }
}

// ========================
// 5️⃣ TIMER2 INIT (LED TOGGLE INTERRUPT)
// ========================
void TIM2_Init(void)
{
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    TIM2->PSC = 7200-1;     // Prescaler
    TIM2->ARR = 10000-1;    // Auto-reload
    TIM2->DIER |= TIM_DIER_UIE; // Update interrupt enable
    TIM2->CR1 |= TIM_CR1_CEN;

    NVIC_EnableIRQ(TIM2_IRQn);
}

void TIM2_IRQHandler(void)
{
    if(TIM2->SR & TIM_SR_UIF)
    {
        TIM2->SR &= ~TIM_SR_UIF;
        GPIOC->ODR ^= GPIO_ODR_ODR13; // Toggle LED
    }
}

// ========================
// 6️⃣ ADC1 INIT (SINGLE CHANNEL READ)
// ========================
void ADC1_Init(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

    ADC1->SQR3 = 0;          // Channel 0 (PA0)
    ADC1->SMPR2 = 7 << 0;    // Sample time 239.5 cycles
    ADC1->CR2 |= ADC_CR2_ADON;
}

uint16_t ADC1_Read(void)
{
    ADC1->CR2 |= ADC_CR2_ADON; // start conversion
    while(!(ADC1->SR & ADC_SR_EOC));
    return ADC1->DR;
}

// ========================
// 7️⃣ MAIN FUNCTION
// ========================
int main(void)
{
    // Initialize peripherals
    GPIO_Init();
    SysTick_Config(72000); // 1ms tick
    EXTI0_Init();
    UART1_Init();
    TIM2_Init();
    ADC1_Init();

    UART1_SendString("STM32F103C8T6 Bare-Metal Demo\r\n");

    while(1)
    {
        uint16_t adc = ADC1_Read();
        char buf[20];
        int len = sprintf(buf, "ADC=%d\r\n", adc);
        UART1_SendString(buf);
        Delay_ms(1000);
    }
}
